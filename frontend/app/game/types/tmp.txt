import { useContext, useEffect, useRef, useState } from 'react';
import Matter from 'matter-js';
import gameSocket, { GameContext } from '../../context/gameSockets';
import { ballCoordinates, pladdleCoordinates, playersCoordinates } from '../types/interfaces';
import { usePathname } from 'next/navigation';


const PongZoneQueue = () => {

    const canvasRef = useRef(null);

    const width = 20;
    const height = 150;
    // let speedR = 20;
    // let speedL = 20;
    
    const   [matchready, setMatchready] = useState<boolean>(false);
    const   [pongzone, setPongzone] = useState({width: 0, height: 0});
    const   {data, setData, gameId, setGameId} = useContext(GameContext);
    
    useEffect(() => {
        const { Engine, Render, World, Bodies, Composite, Runner} = Matter;
        const engine = Engine.create();
        const render = Render.create({
            canvas: canvasRef.current,
            engine: engine,
            options: {
                background: '#ffffff',
                wireframes: false,
            } 
        });
    
        const minY = render.bounds.min.y;
        const minX = render.bounds.min.x;
        const maxY = render.bounds.max.y;
        const maxX = render.bounds.max.x;
        setPongzone({width: maxX, height: maxY});
        // // console.log(`front : h-${maxY} & w-${maxX}`);
    
        const midleVertical = ((maxY - minY) / 2) + minY;
        const midleCanvas = ((maxX- minX) / 2) + minX;

        const ball = Matter.Bodies.circle(midleCanvas, midleVertical, 10, {
            // isStatic: false,
            restitution: 0.8, // Bounciness of the ball
            friction: 0.1, // Friction of the ball
            density: 0.04, // Density of the ball
            render: {
                fillStyle: 'red', // Color of the ball
                strokeStyle: 'green', // Border color of the ball
                lineWidth: 5, // Border width of the ball
            },
        });
        let paddleLeft = Bodies.rectangle(minX + width, midleVertical, width, height, { isStatic: true });
        let paddleRight = Bodies.rectangle(maxX - width, midleVertical, width, height, { isStatic: true });
        ball.force.y = 0;
        // var floor = Matter.Bodies.rectangle(maxX / 2, maxY, maxX, 1, {
        //     isStatic: true,
        //     render: {
        //        visible: true,
        //     }
        // });          

        var world = Matter.World.create({
            gravity: { x: 0, y: 0 }
         });
        Composite.add(engine.world, [paddleLeft, paddleRight, ball]);
        Matter.Events.on(engine, 'beforeUpdate', function() {
            engine.world.gravity.y = 0;
        });          
        
        const handleKey = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    // console.log('times--')
                    gameSocket.emit('arrow', 'UP');
                    break;
                case 'ArrowDown':
                    // console.log('times++')
                    gameSocket.emit('arrow', 'DOWN'); 
                    break;
            }
        };
        document.addEventListener('keydown', handleKey);

        gameSocket.on('leftPaddle', (Cordinates: any) => {
            // console.log('Coordinates left : ', Cordinates);
            const paddleL: pladdleCoordinates  = {x: Cordinates.x, y: Cordinates.y};
            Matter.Body.setPosition(paddleLeft, paddleL);
        });

        gameSocket.on('rightPaddle', (Cordinates: any) => {
            // console.log('Coordinates right : ', Cordinates);
            const paddleL: pladdleCoordinates  = {x: Cordinates.x, y: Cordinates.y};
            Matter.Body.setPosition(paddleRight, paddleL);
        });
        
        // gameSocket.on('drawBall', (Cordinates: any) => {
        //     // console.log('Coordinates ball : ', Cordinates)
        //     // const ballCordinates: ballCoordinates  = {x: Cordinates.x, y: Cordinates.y};
        //     const current = {x: (Cordinates.velocityX + Cordinates.x + 10), y: (Cordinates.velocityY + Cordinates.y + 10)};
        //     Matter.Body.setPosition(ball, {x: current.x, y: current.y});
        //     Matter.Body.setVelocity(ball, {x: Cordinates.velocityX, y: Cordinates.velocityY});
        // });
        // let animationFrameId: any;
        // gameSocket.on('drawBall', (Cordinates: any) => {
        // //   // console.log('Coordinates ball : ', Cordinates);
        //   // Cancel the previous animation frame
        // //   if (animationFrameId) {
        // //     cancelAnimationFrame(animationFrameId);
        // //   }
        //   // Request the next animation frame
        // //   const current = {x: (Cordinates.velocityX + Cordinates.x), y: (Cordinates.velocityY + Cordinates.y)};
        // //   animationFrameId = requestAnimationFrame(() => {
        //     //   Cordinates.y = Math.max(minY + 10, Math.min(Cordinates.y, maxY-10));
        //     //   Cordinates.x = Math.max(minX + 10, Math.min(Cordinates.x, maxX- 10));
        //     //   // console.log('cor-x', Cordinates.x);
        //       // console.log('cor-y', Cordinates.y);
        //     //   // console.log('minY', minY + 10);
        //     //   // console.log('maxY', maxY - 10);
        //     //   // console.log('minX', minX + 10);
        //     //   // console.log('maxX', maxX - 10);
        //       if ((Cordinates.y === minY + 10 || Cordinates.y === maxY -10) || (Cordinates.x === minX+10 || Cordinates.x === maxX-10)) {
        //         Matter.Body.setPosition(ball, { x: Cordinates.x, y: Cordinates.y });
        //     }
        //     Matter.Body.setVelocity(ball, { x: Cordinates.velocityX, y: Cordinates.velocityY });
        // });

        //==================
        Matter.Events.on(engine, 'collisionStart', function(event) {
            var pairs = event.pairs;
          
            // Change the direction of the ball when it hits a paddle
            for (var i = 0, j = pairs.length; i != j; ++i) {
                var pair = pairs[i];
          
                if ((pair.bodyA === ball && pair.bodyB === paddleLeft) ||
                    (pair.bodyA === paddleLeft && pair.bodyB === ball) ||
                    (pair.bodyA === ball && pair.bodyB === paddleRight) ||
                    (pair.bodyA === paddleRight && pair.bodyB === ball)) {
          
                    // Reverse the horizontal velocity of the ball
                    ball.velocity.x *= -1;
                }
          
                // Scoring
                if ((pair.bodyA === ball && pair.bodyB === paddleLeft) ||
                    (pair.bodyA === paddleLeft && pair.bodyB === ball)) {
          
                    // Increase score for player 2
                    // score2++;
                } else if ((pair.bodyA === ball && pair.bodyB === paddleRight) ||
                          (pair.bodyA === paddleRight && pair.bodyB === ball)) {
          
                    // Increase score for player 1
                    // score1++;
                }
            }
          });
        //==================
        
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
        
        return () => {
            Render.stop(render);
            World.clear(engine.world);
            Engine.clear(engine);
            gameSocket.off('drawBall');
            gameSocket.off('leftPaddle');
            gameSocket.off('rightPaddle');
        };
        
    }, [matchready]);


    const path = usePathname();
    const startGame = () => {
        // console.log('path name: ', path);
        setMatchready(true);
        // console.log('startGame: ', matchready);
        gameSocket.emit('startGame', {roomId: gameId, ...pongzone});
    };

    return (
        <div className="bg-transparent w-[100%] h-[80%] rounded-[10px] justify-center absolute bottom-0">
            { !matchready && <button onClick={startGame}>START GAME</button>}
            { matchready && <canvas ref={canvasRef} className='bg-transparent w-[100%] h-[100%] rounded-[10px]'/>}
        </div>
    );
};

export default PongZoneQueue;



///=--=-=-=-=-=
import { useContext, useEffect, useRef, useState } from 'react';
import Matter from 'matter-js';
import gameSocket, { GameContext } from '../../context/gameSockets';
import { ballCoordinates, pladdleCoordinates, playersCoordinates } from '../types/interfaces';
import { usePathname } from 'next/navigation';
import { exit } from 'process';


const PongZoneQueue = () => {

    const canvasRef = useRef(null);

    const width = 20;
    const height = 150;
    
    const   [matchready, setMatchready] = useState<boolean>(false);
    const   [pongzone, setPongzone] = useState({width: 0, height: 0});
    const   {data, setData, gameId, setGameId} = useContext(GameContext);
    
    useEffect(() => {

        const { Engine, Render, World, Bodies, Composite, Runner} = Matter;
        
        const engine = Engine.create(); 
        const render = Render.create({
            canvas: canvasRef.current,
            engine: engine,
            options: {
                background: '#ffffff',
                wireframes: false,
            } 
        });
    
        const minY = render.bounds.min.y;
        const minX = render.bounds.min.x;
        const maxY = render.bounds.max.y;
        const maxX = render.bounds.max.x;
        setPongzone({width: maxX, height: maxY});
        // // console.log(`front : h-${maxY} & w-${maxX}`);
    
        const midleVertical = ((maxY - minY) / 2) + minY;
        const midleCanvas = ((maxX- minX) / 2) + minX;

        let wallTop = Bodies.rectangle(400, 0, 800, 20, { isStatic: true , friction: 0,restitution: 1,});
        let wallBottom = Bodies.rectangle(400, 600, 800, 20, { isStatic: true /*, friction: 0,restitution: 1,*/});
        let wallLeft = Bodies.rectangle(0, 300, 20, 600, { isStatic: true/* , friction: 0,restitution: 1,*/});
        let wallRight = Bodies.rectangle(800, 300, 20, 600, { isStatic: true/*, friction: 0 ,restitution: 1,*/});

        Composite.add(engine.world, [wallTop, wallBottom, wallLeft, wallRight]);

        const ball = Matter.Bodies.circle(midleCanvas, midleVertical, 10, {
            // isStatic: false,
            restitution: 1, // Bounciness of the ball
            friction: 0.5, // Friction of the ball
            density: 0.04, // Density of the ball
            inertia: 0,
            frictionAir: 0,
            frictionStatic: 0,
            // speed: 8,
            // force: {
            //     x:0.5,
            //     y:0,
            // },
            render: {
                fillStyle: 'red', // Color of the ball
                strokeStyle: 'green', // Border color of the ball
                lineWidth: 5, // Border width of the ball
            },
        });
        let paddleLeft = Bodies.rectangle(minX + width, midleVertical, width, height, {
            // isStatic: true,
            // friction: 0,
            // restitution: 1,
        });
        let paddleRight = Bodies.rectangle(maxX - width, midleVertical, width, height, {
            // isStatic: true ,
            // friction: 0,
            // restitution: 1,
        });

        // ball.force.y = 0;       
        Matter.Body.applyForce(ball, ball.position, {x: 0.35, y: 0.01});
        // engine.world.gravity.y = 0;

        Composite.add(engine.world, [paddleLeft, paddleRight, ball]);
        Matter.Events.on(engine, 'beforeUpdate', function() {
            engine.world.gravity.y = 0;
        });     
        
        const handleKey = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    // console.log('times--')
                    gameSocket.emit('arrow', 'UP');
                    break;
                case 'ArrowDown':
                    // console.log('times++')
                    gameSocket.emit('arrow', 'DOWN'); 
                    break;
            }
        };
        document.addEventListener('keydown', handleKey);

        gameSocket.on('leftPaddle', (Cordinates: any) => {
            // console.log('Coordinates left : ', Cordinates);
            const paddleL: pladdleCoordinates  = {x: Cordinates.x, y: Cordinates.y};
            // paddleLeft.position.x = Cordinates.x;
            // paddleLeft.position.y = Cordinates.y;
            // Matter.Body.setPosition(paddleLeft, paddleL);
            Matter.Body.setVelocity(paddleLeft, {x: 0, y:5});
        });

        gameSocket.on('rightPaddle', (Cordinates: any) => {
            // console.log('Coordinates right : ', Cordinates);
            const paddleL: pladdleCoordinates  = {x: Cordinates.x, y: Cordinates.y};
            // Matter.Body.setPosition(paddleRight, paddleL);
            Matter.Body.setVelocity(paddleLeft, {x: 0, y:5});
        });

        // Matter.Events.on(engine, 'collisionStart', function(event: any) {
        //     var pairs = event.pairs;
        //     // const midleVertical = ((maxY - minY) / 2) + minY;
        //     // const midleCanvas = ((maxX- minX) / 2) + minX;

        //     for (var i = 0, j = pairs.length; i != j; ++i) {
        //         var pair = pairs[i];
                
        //         if ((pair.bodyA === wallTop && pair.bodyB === ball) || (pair.bodyB === wallTop && pair.bodyA === ball)) {
        //             //--=--
        //             // if (ball.position.x <= midleCanvas)
        //             //     Matter.Body.applyForce(ball, ball.position, {x: 0.70, y: 0.2});
        //             // if (ball.position.x > midleCanvas && ball.position.y >= midleVertical)
        //             //     Matter.Body.applyForce(ball, ball.position, {x: -0.70, y: 0.2});
        //             // // else
        //             //     Matter.Body.applyForce(ball, ball.position, {x: -1, y: 0.2});
        //         }
        //         if ((pair.bodyA === wallBottom && pair.bodyB === ball) || (pair.bodyB === wallBottom && pair.bodyA === ball)) {
        //             //--=--
        //             // if (ball.position.x >= midleCanvas)
        //             //     Matter.Body.applyForce(ball, ball.position, {x: 0.70, y: -0.2});
        //             // if (ball.position.x < midleCanvas)
        //             //     Matter.Body.applyForce(ball, ball.position, {x: -0.70, y: -0.2});
        //             // Matter.Body.applyForce(ball, ball.position, {x: -1, y: -0.2});
        //         }
        //         if ((pair.bodyA === wallRight && pair.bodyB === ball) || (pair.bodyB === wallRight && pair.bodyA === ball)) {
        //             // new Promise(resolve => setTimeout(resolve, 3000));
        //             // // Matter.Body.setPosition(ball, {x: midleCanvas, y: midleVertical});
        //             // // console.log('gooal');
        //         }
        //         if ((pair.bodyA === wallLeft && pair.bodyB === ball) || (pair.bodyB === wallLeft && pair.bodyA === ball)) {
        //             // new Promise(resolve => setTimeout(resolve, 3000));
        //             // // Matter.Body.setPosition(ball, {x: midleCanvas, y: midleVertical});
        //             // // console.log('gooal');
        //         }
        //         if ((pair.bodyA === ball && pair.bodyB === paddleRight) || (pair.bodyA === paddleRight && pair.bodyB === ball)) {
        //             //--=--
        //         }
        //         if ((pair.bodyA === ball && pair.bodyB === paddleLeft) || (pair.bodyA === paddleLeft && pair.bodyB === ball)) {
        //             //--=--                  
        //         }
        //         // Scoring
        //         if ((pair.bodyA === ball && pair.bodyB === paddleLeft) ||
        //             (pair.bodyA === paddleLeft && pair.bodyB === ball)) {
        //             // Increase score for player 2
        //         } else if ((pair.bodyA === ball && pair.bodyB === paddleRight) ||
        //                   (pair.bodyA === paddleRight && pair.bodyB === ball)) {
        //             // Increase score for player 1
        //         }
        //     }
        // }, );

        //--=
        // Matter.Events.on(engine, 'beforeUpdate', function(event) {
        //     //--=--
        // });
        const interval = setTimeout(() => {
            // ball.position.x += ballVelocityX * 1.5;
            // ball.position.y += ballVelocityY * 1.5;
            Matter.Body.setVelocity(ball, {
                x: ((Math.random() > 0.5) ? 1 : -1) * Math.floor((Math.random() * 7) + 6),
                y: ((Math.random() > 0.5) ? 1 : -1) * Math.floor((Math.random() * 7) + 6)
            });
            // Matter.Body.setPosition(ball, {x: ball.position.x, y: ball.position.y});
        }, 1000 / 10 );
        //--=
        Matter.Events.on(engine, 'collisionStart', function(event: any) {
            var pairs = event.pairs;
         
            for (var i = 0, j = pairs.length; i != j; ++i) {
                var pair = pairs[i];
         
                if ((pair.bodyA === ball && pair.bodyB === paddleRight) || (pair.bodyA === paddleRight && pair.bodyB === ball)) {
                    // Ball hits the right paddle
                    let dx = ball.position.x - paddleRight.position.x;
                    let dy = ball.position.y - paddleRight.position.y;
                    let angle = Math.atan2(dy, dx);
                    Matter.Body.setVelocity(ball, {
                        x: ball.velocity.x * Math.cos(angle),
                        y: -ball.velocity.y * Math.sin(angle)
                    });
                }
         
                if ((pair.bodyA === ball && pair.bodyB === paddleLeft) || (pair.bodyA === paddleLeft && pair.bodyB === ball)) {
                    // Ball hits the left paddle
                    let dx = ball.position.x - paddleLeft.position.x;
                    let dy = ball.position.y - paddleLeft.position.y;
                    let angle = Math.atan2(dy, dx);
                    Matter.Body.setVelocity(ball, {
                        x: -ball.velocity.x * Math.cos(angle),
                        y: -ball.velocity.y * Math.sin(angle)
                    });
                }
            }
         });
        
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
        
        return () => {
            // clearTimeout(interval);
            Render.stop(render);
            World.clear(engine.world);
            Engine.clear(engine);
            gameSocket.off('drawBall');
            gameSocket.off('leftPaddle');
            gameSocket.off('rightPaddle');
        };
        
    }, [matchready]);


    const path = usePathname();
    const startGame = () => {
        // console.log('path name: ', path);
        setMatchready(true);
        // console.log('startGame: ', matchready);
        gameSocket.emit('startGame', {roomId: gameId, ...pongzone});
    };

    return (
        <div className="bg-transparent w-[100%] h-[80%] rounded-[10px] justify-center absolute bottom-0">
            { !matchready && <button onClick={startGame}>START GAME</button>}
            { matchready && <canvas ref={canvasRef} className='bg-transparent w-[100%] h-[100%] rounded-[10px]'/>}
        </div>
    );
};

export default PongZoneQueue;